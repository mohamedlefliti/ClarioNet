import hashlib
import json
from datetime import datetime

# üîπ ClarioNet Block definition
class ClarioBlock:
    def __init__(self, index, timestamp, data, previous_hash, explanation=None):
        self.index = index
        self.timestamp = timestamp
        self.data = data
        self.previous_hash = previous_hash
        self.explanation = explanation or self.generate_explanation()
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        block_string = json.dumps({
            'index': self.index,
            'timestamp': self.timestamp,
            'data': self.data,
            'previous_hash': self.previous_hash,
            'explanation': self.explanation
        }, sort_keys=True).encode()
        return hashlib.sha256(block_string).hexdigest()

    def generate_explanation(self):
        # üß† ClarioNet-style logic interpretation
        if isinstance(self.data, dict):
            if "amount" in self.data and "from" in self.data and "to" in self.data:
                return f"Transfer of {self.data['amount']} units from {self.data['from']} to {self.data['to']}."
            elif "contract" in self.data:
                return f"Smart contract executed: {self.data['contract']} with defined conditions."
        return "No specific logical explanation available."

# üîó ClarioNet chain structure
class ClarioChain:
    def __init__(self):
        self.chain = [self.create_genesis_block()]

    def create_genesis_block(self):
        return ClarioBlock(0, str(datetime.now()), {"message": "Genesis Block"}, "0")

    def get_last_block(self):
        return self.chain[-1]

    def add_block(self, data):
        last_block = self.get_last_block()
        new_block = ClarioBlock(
            index=last_block.index + 1,
            timestamp=str(datetime.now()),
            data=data,
            previous_hash=last_block.hash
        )
        self.chain.append(new_block)

    def is_chain_valid(self):
        for i in range(1, len(self.chain)):
            current = self.chain[i]
            previous = self.chain[i - 1]
            if current.hash != current.calculate_hash():
                return False
            if current.previous_hash != previous.hash:
                return False
        return True

    def display_chain(self):
        for block in self.chain:
            print(f"üîπ ClarioBlock {block.index}")
            print(f"  ‚è±Ô∏è Timestamp: {block.timestamp}")
            print(f"  üì¶ Data: {block.data}")
            print(f"  üß† Explanation: {block.explanation}")
            print(f"  üîê Hash: {block.hash}")
            print("-" * 50)

# üßë‚Äç‚öñÔ∏è ClarioNet Supervisory Node
class ClarioNode:
    def __init__(self, node_id):
        self.node_id = node_id

    def vote_on_block(self, block, reason):
        vote = "yes"  # Force all nodes to accept
        print(f"üó≥Ô∏è ClarioNode {self.node_id} voted {vote} on modifying Block {block.index} due to: {reason}")
        return vote

# üó≥Ô∏è ClarioNet Voting System
class ClarioVoting:
    def __init__(self, supervisory_nodes):
        self.supervisory_nodes = supervisory_nodes

    def propose_block_modification(self, block, reason):
        votes = [node.vote_on_block(block, reason) for node in self.supervisory_nodes]
        yes_votes = votes.count("yes")
        total = len(votes)
        print(f"\nüìä Voting result: {yes_votes}/{total} approved the modification.")
        if yes_votes / total >= 2/3:
            print("‚úÖ Modification accepted. Proceeding with ClarioNet-style explanation.")
            return True
        else:
            print("‚ùå Modification rejected. Block remains unchanged.")
            return False

# üß™ ClarioNet Test Run
if __name__ == "__main__":
    clario = ClarioChain()
    clario.add_block({"from": "UserA", "to": "UserB", "amount": 250})
    clario.add_block({"from": "UserB", "to": "UserC", "amount": 100})
    clario.add_block({"contract": "Distribute 5% profit if balance exceeds 1000 units"})

    clario.display_chain()
    print("\n‚úÖ Is the ClarioNet chain valid?", "Yes" if clario.is_chain_valid() else "No")

    # Create ClarioNet supervisory nodes
    nodes = [ClarioNode(f"Node{i}") for i in range(1, 6)]
    voting = ClarioVoting(nodes)

    # Propose a block modification
    block_to_modify = clario.chain[1]
    reason = "Discrepancy in sender identity"
    voting.propose_block_modification(block_to_modify, reason)
